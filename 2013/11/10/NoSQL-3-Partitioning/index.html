<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> NoSQL 3 - Partitioning · Zhipeng Jiang</title><meta name="description" content="NoSQL 3 - Partitioning - Zhipeng Jiang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/jesusjzp" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/zp-j" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">NoSQL 3 - Partitioning</h1><div class="post-time">Nov 10, 2013</div><div class="post-content"><p>Extracted from <strong>Christof Strauch, <a href="http://www.christof-strauch.de/nosqldbs.pdf" target="_blank" rel="external">NoSQL Databases</a>, P37-44,  2010</strong>.</p>
<h1 id="3-2-Partitioning"><a href="#3-2-Partitioning" class="headerlink" title="3.2 Partitioning"></a>3.2 Partitioning</h1><ul>
<li>Memory Caches</li>
<li>Clustering</li>
<li>Separating Reads from Writes</li>
<li>Sharding</li>
</ul>
<h2 id="3-2-1-Consistent-Hashing"><a href="#3-2-1-Consistent-Hashing" class="headerlink" title="3.2.1 Consistent Hashing"></a>3.2.1 Consistent Hashing</h2><p>Figures 3.4 and 3.5 illustrate the idea behind the consistent hashing approach. In figure 3.4 there are three red colored nodes A, B and C and four blue colored objects 1–4 that are mapped to a hash-function’s result range which is imagined and pictured as a ring. Which object is mapped to which node is determined by moving clockwise around the ring. So, objects 4 and 1 are mapped to node A, object 2 to node B and object 3 to node C. When a node leaves the system, cache objects will get mapped to their adjacent node (in clockwise direction) and when a node enters the system it will get hashed onto the ring and will overtake objects. An example is depicted in figure 3.5 where compared to figure 3.4 node C left and node D entered the system, so that now objects 3 and 4 will get mapped to node D. This shows that by changing the number of nodes not all objects have to be remapped to the new set of nodes but only part of the objects.</p>
<p><img src="http://media-cache-ak0.pinimg.com/originals/e6/af/0a/e6af0aaed3aab954d2bbc1ffaaaf74c0.jpg" alt="pic"></p>
<h2 id="3-2-2-Read-and-Write-Operations-on-Partitioned-Data"><a href="#3-2-2-Read-and-Write-Operations-on-Partitioned-Data" class="headerlink" title="3.2.2 Read and Write Operations on Partitioned Data"></a>3.2.2 Read and Write Operations on Partitioned Data</h2><p>The Project Voldemort team points out that three parameters are specifically important regarding read as well as write<br>operations (cf. [K+ 10b]):</p>
<ul>
<li><strong>N</strong> The number of replicas for the data or the piece of data to be read or written.</li>
<li><strong>R</strong> The number of machines contacted in read operations.</li>
<li><strong>W</strong> The number of machines that have to be blocked in write operations5 .</li>
</ul>
<p>In the interest to provide e. g. the read-your-own-writes consistency model the following relation between the above parameters becomes necessary:</p>
<center><strong> R+W &gt; N </strong></center>

<h3 id="3-2-3Membership-Changes"><a href="#3-2-3Membership-Changes" class="headerlink" title="3.2.3Membership Changes"></a>3.2.3Membership Changes</h3><p>When a new node joins the system the following actions have to happen (cf. [Ho09a]):</p>
<ol>
<li>The newly arriving node announces its presence and its identifier to adjacent nodes or to all nodes via broadcast.</li>
<li>The neighbors of the joining node react by adjusting their object and replica ownerships.</li>
<li>The joining node copies datasets it is now responsible for from its neighbours. This can be done in bulk and also asynchronously.</li>
<li>If, in step 1, the membership change has not been broadcasted to all nodes, the joining node is now announcing its arrival.</li>
</ol>
<p>In figure 3.8, this process is illustrated. Node X joins a system for which a replication factor of three is configured. It is hashed between A and B, so that the nodes H, A and B transfer data to the new node X and after that the nodes B, C and D can drop parts of their data for which node X is now responsible as a third replica (in addition to nodes H, A and B).</p>
<p><img src="http://media-cache-ec0.pinimg.com/originals/b8/d7/50/b8d75006aa547edf5788f6806339a96f.jpg" alt="pic"></p>
<p>When a node leaves the system the following actions have to occur:</p>
<ol>
<li>Nodes within the system need to detect whether a node has left as it might have crashed and not been able to notify the other nodes of its departure. It is also common in many systems that no notifications get exchanged when a node leaves. If the nodes of the system communicate regularly e. g. via the Gossip protocol they are able to detect a node’s departure because it no longer responds.</li>
<li>If a node’s departure has been detected, the neighbors of the node have to react by exchanging data with each other and adjusting their object and replica ownerships.</li>
</ol>
<p>Figure 3.9 shows the actions to be taken when node B—due to a crash—leaves the system. Nodes C, D and E become responsible for new intervals of hashed objects and therefore have to copy data from nodes in counterclockwise direction and also reorganize their internal representation of the intervals as the RangeAB and RangeBC now have collapsed to RangeAC .</p>
<p><img src="http://media-cache-ec0.pinimg.com/originals/84/5c/7a/845c7af504f4f4b85d04cd67c7f6042c.jpg" alt="pic"></p>
</div></article></div></section><footer><div class="paginator"><a href="/2013/11/11/NoSQL-4-Strorage-Layout/" class="prev">PRVE</a><a href="/2013/11/06/Algorithm-04-Prime-Problem/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'ZhipengJiang';
var disqus_identifier = '2013/11/10/NoSQL-3-Partitioning/';
var disqus_title = 'NoSQL 3 - Partitioning';
var disqus_url = 'http://yoursite.com/2013/11/10/NoSQL-3-Partitioning/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//ZhipengJiang.disqus.com/count.js" async></script><div class="copyright"><p>© 2013 - 2016 <a href="http://yoursite.com">Zhipeng Jiang</a>, unless otherwise noted.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-47515905-1",'auto');ga('send','pageview');</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>